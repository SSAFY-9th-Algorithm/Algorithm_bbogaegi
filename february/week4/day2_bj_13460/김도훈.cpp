#include <iostream>
using namespace std;

// 구슬이 한칸씩 움직이는 것이 아니라
// 최대한 끝까지 갈 수 있을때까지 간다.
// 매 단계마다 구슬의 위치를 기억해줘야 한다. -> 큐를 이용하자
struct Position {
	int Ry;
	int Rx;
	int By;
	int Bx;
	int cnt;	// 빨간공, 파란공, 횟수를 저장하는 구조체
};

// visited 여부를 확인할 때 빨간공과 파란공의 위치를 모두 체크해줘야한다.
// visited[Ry][Rx][By][Bx] 이런것도 가능하구나...
// 방문 여부 확인은 이렇게 설계하고
// BFS를 이용하여 구슬들이 갈 수 있는 경우를 확인해보자

void bfs() {
	// 방향 배열 써주고
	// queue~ BFS 그대로 구현
	// 이때 조건들을 잘봐줘야할 것같다

	// 한칸씩 움직이는 것이 아니므로 다음 좌표는 현재 좌표에서 방향 벡터만큼
	// 계속 더해주는 식으로 구현 -> 아마 while 문

	// 조건들을 모두 써주고 모두 만족하면 다음 좌표들을 queue에 넣어준다.
	// 조건들이 좀 까다로운데 구현해보자...
	// 공이 겹칠 때 주의 해줘야 하는데 ***내일 해야지
}


int main() {


}